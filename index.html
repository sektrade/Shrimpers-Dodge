<!-- Shrimp Dodge - Single-file HTML game
     - Use arrow keys or A/D to move left/right
     - Avoid falling knives, lemons, and pans
     - Character: red shrimp with glasses and wizard hat (drawn on canvas)
     - Save this file as ShrimpDodge.html and open in a browser
-->
<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shrimp Dodge</title>
<style>
  :root{--bg:#0b1220;--panel:#0f1a2b;--accent:#ffd166}
  html,body{height:100%;margin:0;font-family:Inter, system-ui, sans-serif;background:linear-gradient(180deg,#1ca3ec 0%, #005f99 100%);color:#e6eef8}
  .wrap{display:flex;gap:20px;align-items:flex-start;justify-content:center;padding:24px}
  canvas{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 10px 30px rgba(2,8,23,0.7)}
  .ui{width:320px;max-width:40vw;padding:12px;background:rgba(255,255,255,0.03);border-radius:12px}
  h1{font-size:20px;margin:0 0 8px}
  .row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
  button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700}
  .small{font-size:13px;color:#cfe6ff}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .hint{font-size:13px;opacity:0.9}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="640" height="720"></canvas>
  <div class="ui">
    <h1>Shrimp Dodge</h1>
    <div class="row"><div>Score</div><div id="score">0</div></div>
    <div class="row"><div>Lives</div><div id="lives">3</div></div>
    <div class="row"><div>Speed</div><div id="speed">1.0Ã—</div></div>
    <div class="row controls">
      <button id="start">BaÅŸlat</button>
      <button id="pause">Duraklat</button>
      <button id="reset">SÄ±fÄ±rla</button>
    </div>
    <p class="hint small">Kontroller: Sol/SaÄŸ ok tuÅŸlarÄ± veya A/D. Mobilde ekranda sola/saÄŸa dokun.</p>
    <p class="hint small">Karakter: kÄ±rmÄ±zÄ± karides, gÃ¶zlÃ¼k ve bÃ¼yÃ¼cÃ¼ ÅŸapkasÄ±. Engeller: bÄ±Ã§ak, limon, tava.</p>
    <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="toggleSound">Ses: AÃ§Ä±k</button>
      <button id="hardMode">Zor Modu</button>
    </div>
    <p class="small" style="margin-top:12px">DosyayÄ± bilgisayarÄ±nÄ±za kaydedip Ã§ift tÄ±klayarak oynayÄ±n.</p>
  </div>
</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let scoreEl = document.getElementById('score');
  let livesEl = document.getElementById('lives');
  let speedEl = document.getElementById('speed');
  let startBtn = document.getElementById('start');
  let pauseBtn = document.getElementById('pause');
  let resetBtn = document.getElementById('reset');
  let toggleSoundBtn = document.getElementById('toggleSound');
  let hardModeBtn = document.getElementById('hardMode');

  let keys = {};
  let touchDir = 0;
  let soundOn = true;
  let hardMode = false;

  // Game state
  let player = {x: W/2, y: H - 140, w: 96, h: 64, speed: 6};
  let obstacles = [];
  let frame = 0;
  let score = 0;
  let lives = 3;
  let running = false;
  let paused = false;
  let spawnRate = 90; // frames
  let fallSpeed = 2.0;
     let showCommunity = false;
let communityTimer = 0;
let lastMilestone = 0;


  // simple sound
  const beep = (freq=440, time=0.05) => {
    if(!soundOn) return;
    try{
      const o = new (window.AudioContext || window.webkitAudioContext)();
      const s = o.createOscillator();
      const g = o.createGain();
      s.type = 'sine'; s.frequency.value = freq;
      s.connect(g); g.connect(o.destination);
      g.gain.value = 0.05;
      s.start(); s.stop(o.currentTime + time);
      s.onended = ()=>o.close();
    } catch(e){}
  }

  function resetGame(){
    obstacles = [];
    frame = 0; score = 0; lives = 3; fallSpeed = 2.0; spawnRate = 90; running = false; paused=false;
    updateUI();
    player.x = W/2; player.y = H - 140;
  }
  resetGame();

  function updateUI(){
    scoreEl.textContent = Math.floor(score);
    livesEl.textContent = lives;
    speedEl.textContent = (fallSpeed/2).toFixed(2) + 'Ã—';
    toggleSoundBtn.textContent = 'Ses: ' + (soundOn? 'AÃ§Ä±k':'KapalÄ±');
    hardModeBtn.textContent = hardMode? 'Zor Modu: AÃ§Ä±k' : 'Zor Modu';
  }

  // draw the shrimp character
  function drawShrimp(ctx, x, y, scale=1){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale,scale);
    // body
    ctx.beginPath();
    ctx.ellipse(0,0,48,22,0,0,Math.PI*2);
    ctx.fillStyle = '#e03a3a';
    ctx.fill();
    // tail segments
    ctx.beginPath();
    ctx.moveTo(48,0);
    ctx.lineTo(70,-18);
    ctx.lineTo(60,0);
    ctx.lineTo(70,18);
    ctx.closePath();
    ctx.fillStyle = '#d23131'; ctx.fill();
    // stripes
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.fillRect(-10,-20,8,40);
    ctx.fillRect(4,-18,8,36);
    // eye stalk
    ctx.beginPath(); ctx.arc(-18,-6,8,0,Math.PI*2); ctx.fillStyle='#ffffff'; ctx.fill();
    ctx.beginPath(); ctx.arc(-22,-6,3,0,Math.PI*2); ctx.fillStyle='#222'; ctx.fill();
    // glasses
    ctx.beginPath(); ctx.rect(-34,-18,30,18); ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.fill();
    ctx.beginPath(); ctx.rect(-8,-18,28,18); ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.fill();
    ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.strokeRect(-34,-18,30,18); ctx.strokeRect(-8,-18,28,18);
    ctx.beginPath(); ctx.moveTo(-4,-9); ctx.lineTo(-6,-9); ctx.stroke();
    // wizard hat
    ctx.beginPath(); ctx.moveTo(-3,-28); ctx.lineTo(20,-60); ctx.lineTo(40,-50); ctx.lineTo(12,-18); ctx.closePath(); ctx.fillStyle='#2b2a7a'; ctx.fill();
    ctx.beginPath(); ctx.ellipse(6,-14,46,10,0,0,Math.PI*2); ctx.fillStyle='#1b1a45'; ctx.fill();
    // shine on hat
    ctx.beginPath(); ctx.moveTo(20,-52); ctx.quadraticCurveTo(18,-46,26,-44); ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=2; ctx.stroke();

    ctx.restore();
  }

  function spawnObstacle(){
    const types = ['knife','lemon','pan'];
    let type = types[Math.floor(Math.random()*types.length)];
    if(hardMode){ // more knives in hard mode
      type = Math.random() < 0.5? 'knife' : (Math.random()<0.6? 'pan':'lemon');
    }
    const w = type==='lemon'?48: type==='pan'?72: 18;
    const h = type==='lemon'?48: type==='pan'?28: 60;
    const x = Math.random()*(W - w) + w/2;
    obstacles.push({x, y: -100, w, h, type, rot: Math.random()*Math.PI*2, spin: (Math.random()-0.5)*0.1});
  }

  function drawObstacle(o){
    ctx.save(); ctx.translate(o.x, o.y); ctx.rotate(o.rot);
    if(o.type==='lemon'){
      ctx.beginPath(); ctx.arc(0,0,24,0,Math.PI*2); ctx.fillStyle='#ffd94d'; ctx.fill();
      ctx.beginPath(); ctx.arc(0,-6,10,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.06)'; ctx.fill();
      ctx.lineWidth=2; ctx.strokeStyle='#f2c94c'; ctx.stroke();
    } else if(o.type==='pan'){
      ctx.beginPath(); ctx.ellipse(0,0,32,16,0,0,Math.PI*2); ctx.fillStyle='#222'; ctx.fill();
      ctx.fillRect(28,-6,26,12);
      ctx.beginPath(); ctx.arc(8,0,12,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fill();
    } else if(o.type==='knife'){
      ctx.fillStyle='#c7c7c7'; ctx.fillRect(-8,-28,16,56);
      ctx.beginPath(); ctx.moveTo(-8,-28); ctx.lineTo(0,-40); ctx.lineTo(8,-28); ctx.fillStyle='#e9e9e9'; ctx.fill();
      ctx.fillStyle='#6b6b6b'; ctx.fillRect(-8,18,16,6);
    }
    ctx.restore();
  }

  function rectsCollide(a,b){
    return !(a.x + a.w/2 < b.x - b.w/2 || a.x - a.w/2 > b.x + b.w/2 || a.y + a.h/2 < b.y - b.h/2 || a.y - a.h/2 > b.y + b.h/2);
  }

  function gameLoop(){
    if(!running || paused) return;
    frame++;
    // update spawn rate & difficulty over time
    if(frame % 600 === 0){ fallSpeed += 0.4; spawnRate = Math.max(30, spawnRate - 8); }

    // input
    if(keys['ArrowLeft'] || keys['a']) player.x -= player.speed * (hardMode?1.1:1);
    if(keys['ArrowRight'] || keys['d']) player.x += player.speed * (hardMode?1.1:1);
    if(touchDir) player.x += touchDir * player.speed * 1.5;
    // clamp
    player.x = Math.max(player.w/2, Math.min(W - player.w/2, player.x));

    // spawn
    if(frame % Math.max(6, Math.floor(spawnRate/(hardMode?1.2:1))) === 0){ spawnObstacle(); }

    // update obstacles
    for(let i = obstacles.length-1;i>=0;i--){
      let o = obstacles[i];
      o.y += fallSpeed + (o.type==='knife'?2:0);
      o.rot += o.spin;
      if(o.y - o.h/2 > H + 20){ obstacles.splice(i,1); score += 1; beep(880, 0.02); }
    }

    // collisions
    const pRect = {x:player.x, y:player.y, w:player.w, h:player.h};
    for(let i=obstacles.length-1;i>=0;i--){
      let o=obstacles[i];
      const oRect = {x:o.x, y:o.y, w:o.w, h:o.h};
      if(rectsCollide(pRect, oRect)){
        // hit
        obstacles.splice(i,1);
        lives -= 1;
        beep(220,0.08);
        if(lives <= 0){ running = false; showGameOver(); }
      }
    }

    // score growth
    score += 0.02;
    // render
    render();
    updateUI();

    requestAnimationFrame(gameLoop);
  }

  function render(){
    // clear
    ctx.clearRect(0,0,W,H);
    // background subtle grid
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    for(let i=0;i<20;i++){
      ctx.fillRect(0,(i*60 + (frame%60))*1.0 % H, W, 1);
    }
       // render fonksiyonunun en sonunda, ctx.restore() Ã§aÄŸrÄ±sÄ±ndan hemen Ã¶nce ekle
if (score >= 30) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.6)';       // yarÄ± ÅŸeffaf arka plan
  ctx.fillRect(W/2 - 220, H/2 - 60, 440, 120);
  
  ctx.fillStyle = '#00e0ff';               // parlak mavi yazÄ±
  ctx.font = 'bold 32px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Shrimpers CommunityðŸ’Ž', W/2, H/2 + 12);
  ctx.restore();
     //--------------
     if (showCommunity && Date.now() - communityTimer < 200) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(W/2 - 220, H/2 - 60, 440, 120);

  ctx.fillStyle = '#00e0ff';
  ctx.font = 'bold 32px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Shrimpers CommunityðŸ’Ž', W/2, H/2 + 12);
  ctx.restore();
}
//--------
}

    ctx.restore();

    // draw player
    drawShrimp(ctx, player.x, player.y, 1.0);

    // draw obstacles
    for(let o of obstacles) drawObstacle(o);

    // HUD small
    ctx.save(); ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(8,8,160,36); ctx.fillStyle='#fff'; ctx.font='16px sans-serif'; ctx.fillText('Score: ' + Math.floor(score), 16, 32); ctx.restore();
  }

  function showGameOver(){
    // overlay
    ctx.save(); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#fff'; ctx.font='48px sans-serif'; ctx.textAlign='center'; ctx.fillText('Oyun Bitti', W/2, H/2 - 20);
    ctx.font='20px sans-serif'; ctx.fillText('Skor: ' + Math.floor(score), W/2, H/2 + 18);
    ctx.restore();
  }

  // input handlers
  window.addEventListener('keydown', e=>{ keys[e.key] = true; if(e.key===' ' && !running) { startGame(); } });
  window.addEventListener('keyup', e=>{ keys[e.key] = false; });

  // touch controls (simple split-screen)
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); const t = e.touches[0]; const rect = canvas.getBoundingClientRect(); const x = t.clientX - rect.left; touchDir = x < rect.width/2 ? -1 : 1; });
  canvas.addEventListener('touchmove', e=>{ e.preventDefault(); const t = e.touches[0]; const rect = canvas.getBoundingClientRect(); const x = t.clientX - rect.left; touchDir = x < rect.width/2 ? -1 : 1; });
  canvas.addEventListener('touchend', e=>{ touchDir = 0; });

  startBtn.addEventListener('click', ()=>{ startGame(); });
  pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused? 'Devam et' : 'Duraklat'; if(!paused) requestAnimationFrame(gameLoop); });
  resetBtn.addEventListener('click', ()=>{ resetGame(); updateUI(); render(); });
  toggleSoundBtn.addEventListener('click', ()=>{ soundOn = !soundOn; updateUI(); });
  hardModeBtn.addEventListener('click', ()=>{ hardMode = !hardMode; updateUI(); });

  function startGame(){ if(running) return; running = true; paused=false; fallSpeed = 2.0 + (hardMode?1.0:0); spawnRate = hardMode?70:90; requestAnimationFrame(gameLoop); }

  // initial draw
  render();

})();
</script>
</body>
</html>
